# TensorRT PTQ量化Calibrator介绍

## 1、使用校准(Calibrator)的PTQ (Post-Training Quantization) 
**注意**：本节描述了已弃用的API。建议使用显式量化。  
 **校准仅适用于INT8量化**
 
 ---
 
在PTQ量化中，TensorRT会为网络中的每个张量计算一个缩放值。这个过程称为校准，需要你提供具有代表性的输入数据，TensorRT在这些数据上运行网络以收集每个激活张量的统计信息。

所需的输入数据量取决于具体应用，但实验表明，大约500张图像足以校准ImageNet分类网络。

给定激活张量的统计信息后，确定最佳缩放值并不是一门精确的科学——它需要在量化表示中的两种误差源之间进行平衡：离散化误差（随着每个量化值表示的范围增大而增加）和截断误差（将值限制在可表示范围内）。因此，TensorRT提供了多种校准器，它们以不同的方式计算缩放值。较旧的校准器还会在GPU上进行层融合，以在校准前优化掉不需要的张量。这在DLA（深度学习加速器）上可能会出现问题，因为融合模式可能不同，并且可以使用`kCALIBRATE_BEFORE_FUSION`量化标志来覆盖。

校准批次大小也会影响`IInt8EntropyCalibrator2`和`IInt8EntropyCalibrator`的截断误差。例如，使用多个小批次的校准数据进行校准可能会导致直方图分辨率降低和缩放值不准确。对于每个校准步骤，TensorRT会更新每个激活张量的直方图分布。如果遇到激活张量中的值大于当前直方图最大值，直方图范围会以2的幂次增加以容纳新的最大值。这种方法在大多数情况下效果良好，除非直方图在最后一个校准步骤中重新分配，导致最终的直方图有一半的空桶。这样的直方图可能会产生较差的校准缩放值。这也使得校准对校准批次的顺序敏感；不同的顺序可能会在不同的点增加直方图大小，从而产生略微不同的校准缩放值。为了避免这个问题，尽可能使用单个大批次进行校准，并确保校准批次是随机化的且具有相似的分布。

- **`IInt8EntropyCalibrator2`**  
熵校准选择张量的缩放因子以优化量化张量的信息论内容，通常会抑制分布中的异常值。这是当前推荐的熵校准器，并且是DLA所必需的。默认情况下，校准在层融合之前进行。校准批次大小可能会影响最终结果。建议用于基于CNN的网络。

- **`IInt8MinMaxCalibrator`**  
此校准器使用激活分布的整个范围来确定缩放因子。它在NLP任务中表现更好。默认情况下，校准在层融合之前进行。建议用于NVIDIA BERT（Google官方实现的优化版本）等网络。

- **`IInt8EntropyCalibrator`**  
这是原始的熵校准器。它比`LegacyCalibrator`简单，通常能产生更好的结果。校准批次大小可能会影响最终结果。默认情况下，校准在层融合之后进行。

- **`IInt8LegacyCalibrator`**  
此校准器用于与TensorRT 2.0 EA兼容。它需要用户参数化，并且是其他校准器效果不佳时的备用选项。默认情况下，校准在层融合之后进行。你可以自定义此校准器以实现百分位最大值。例如，99.99%的百分位最大值在NVIDIA BERT和NeMo ASR模型QuartzNet中观察到具有最佳精度。

在构建INT8引擎时，构建器执行以下步骤：  
1. 构建一个32位引擎，在校准集上运行它，并记录每个张量的激活值分布的直方图。  
2. 从直方图中构建一个校准表，为每个张量提供缩放值。  
3. 根据校准表和网络定义构建INT8引擎。  
校准可能很慢；因此，步骤2的输出（校准表）可以缓存并重复使用。这在给定平台上多次构建相同网络时非常有用，并且所有校准器都支持此功能。

在校准之前，TensorRT会查询校准器实现以查看其是否有访问缓存的校准表。如果有，则直接进入步骤3。缓存数据以指针和长度形式传递。

只要校准在层融合之前进行，校准缓存数据就可以在不同设备之间移植。具体来说，当使用`IInt8EntropyCalibrator2`或`IInt8MinMaxCalibrator`校准器时，或者当设置了`QuantizationFlag::kCALIBRATE_BEFORE_FUSION`时，校准缓存是可移植的。例如，这可以简化工作流程，即在具有独立GPU的机器上构建校准表，然后在嵌入式平台上重复使用。融合在不同平台或设备之间不能保证相同，因此在层融合之后进行校准可能不会产生可移植的校准缓存。校准缓存通常不能跨TensorRT版本移植。

TensorRT还必须量化权重并量化激活。它使用对称量化，并使用权重张量中的最大绝对值计算量化缩放值。对于卷积、反卷积和全连接权重，缩放值是每通道的。  

**注意**：当构建器配置为使用INT8 I/O时，TensorRT仍然期望校准数据为FP32。你可以通过将INT8 I/O校准数据转换为FP32精度来创建FP32校准数据。还要确保FP32转换后的校准数据在`[-128.0F, 127.0F]`范围内，以便可以无损地转换为INT8数据。INT8校准可以与动态范围API一起使用。手动设置动态范围会覆盖从INT8校准生成的动态范围。  

**注意**：校准是确定性的——也就是说，如果你在同一设备上以相同顺序向TensorRT提供相同的校准输入，生成的缩放值在不同运行中将相同。当使用相同设备、相同批次大小并提供相同的校准输入时，校准缓存中的数据将是位级相同的。当使用不同设备、批次大小或校准输入生成时，校准缓存中的确切数据不能保证是位级相同的。

## 2、Calibrator区别
在TensorRT中，PTQ（Post-Training Quantization，训练后量化）用于将浮点模型转换为INT8精度，以提升推理速度并减少内存占用。TensorRT提供了多种校准器（Calibrator）来实现INT8量化，以下是这五种校准器的区别：

### 2.1 **nvinfer1::IInt8EntropyCalibrator2**
   - **校准方法**：基于熵的校准方法。
   - **特点**：这是TensorRT推荐的默认校准器，适用于大多数模型。它通过最小化量化前后的信息损失来选择最佳的量化范围。
   - **优点**：通常能提供较好的精度和性能平衡。
   - **适用场景**：通用模型，尤其是对精度要求较高的场景。

### 2.2 **nvinfer1::IInt8MinMaxCalibrator**
   - **校准方法**：基于最小值和最大值的校准方法。
   - **特点**：直接使用激活值的全局最小值和最大值来确定量化范围。
   - **优点**：实现简单，计算开销小。
   - **缺点**：对异常值敏感，可能导致精度损失。
   - **适用场景**：激活值分布较为均匀且没有明显异常值的模型。

### 2.3 **nvinfer1::IInt8EntropyCalibrator**
   - **校准方法**：基于熵的校准方法（旧版本）。
   - **特点**：与`IInt8EntropyCalibrator2`类似，但实现方式较旧，可能不如`IInt8EntropyCalibrator2`效果好。
   - **优点**：适用于旧版TensorRT。
   - **缺点**：已被`IInt8EntropyCalibrator2`取代，推荐使用后者。
   - **适用场景**：旧版TensorRT兼容性需求。

### 2.4 **nvinfer1::IInt8LegacyCalibrator**
   - **校准方法**：基于百分位的校准方法。
   - **特点**：通过选择激活值的某个百分位（如99%）来确定量化范围，避免异常值的影响。
   - **优点**：对异常值不敏感，适合激活值分布不均匀的模型。
   - **缺点**：需要手动选择百分位，调参较为复杂。
   - **适用场景**：激活值分布不均匀或存在异常值的模型。

### 2.5 **nvinfer1::IInt8Calibrator**
   - **校准方法**：通用的校准接口。
   - **特点**：这是一个基类，其他校准器（如`IInt8EntropyCalibrator2`、`IInt8MinMaxCalibrator`等）都继承自它。用户可以通过继承这个类来实现自定义的校准方法。
   - **优点**：灵活性高，适合需要自定义校准逻辑的场景。
   - **缺点**：需要用户自行实现校准逻辑，开发成本较高。
   - **适用场景**：需要自定义校准方法的场景。

### 2.6 总结
- **推荐使用**：`IInt8EntropyCalibrator2`，它在大多数情况下能提供较好的精度和性能平衡。
- **简单场景**：`IInt8MinMaxCalibrator`，适用于激活值分布均匀的模型。
- **异常值处理**：`IInt8LegacyCalibrator`，适合激活值分布不均匀或存在异常值的模型。
- **自定义需求**：`IInt8Calibrator`，适合需要实现自定义校准逻辑的场景。